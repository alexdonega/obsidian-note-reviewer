---
phase: 04-advanced-ai
plan: 02
type: execute
wave: 2
depends_on: ["03-05"]
files_modified:
  - packages/ai/src/vaultParser.ts
  - packages/ai/src/types.ts
  - apps/portal/src/components/VaultContextPanel.tsx
autonomous: false

must_haves:
  truths:
    - "Parser reads Obsidian markdown files from local filesystem"
    - "Backlinks are extracted from [[wiki-style]] links"
    - "Graph relationships are mapped between notes"
    - "Dataview queries are parsed and executed"
  artifacts:
    - path: "packages/ai/src/vaultParser.ts"
      provides: "Obsidian vault parser for backlinks and graph"
      exports: ["parseVault", "getBacklinks", "getGraph", "parseDataview"]
      min_lines: 250
    - path: "apps/portal/src/components/VaultContextPanel.tsx"
      provides: "UI component displaying vault context"
      min_lines: 120
  key_links:
    - from: "packages/ai/src/vaultParser.ts"
      to: "apps/portal/src/components/VaultContextPanel.tsx"
      via: "import"
      pattern: "parseVault"
---

<objective>
Build Obsidian vault context understanding by parsing backlinks, graph relationships, and dataview queries from local markdown files.

**Purpose:** Deliver AI-02 requirement - AI understands Obsidian vault context including backlinks and graph relationships for intelligent, context-aware suggestions.

**Output:** Complete vault parser with backlink extraction, graph mapping, and dataview support.
</objective>

<context>
@.planning/phases/03-claude-code-integration/03-CONTEXT.md
@packages/ui/types/index.ts

# Existing patterns
@packages/ui/utils/markdownSanitizer.ts
@packages/api/routes/obsidian.ts
</context>

<tasks>

<task type="auto">
  <name>Define vault context types</name>
  <files>packages/ai/src/types.ts</files>
  <action>
    Add to `packages/ai/src/types.ts`:

    ```typescript
    export interface ObsidianNote {
      path: string;
      title: string;
      content: string;
      tags: string[];
      frontmatter: Record<string, any>;
      links: InternalLink[];
      backlinks: InternalLink[];
      created: Date;
      modified: Date;
    }

    export interface InternalLink {
      target: string; // Note path or [[alias]]
      type: 'wiki' | 'markdown' | 'embed';
      position?: { line: number; col: number };
    }

    export interface GraphNode {
      id: string; // Note path
      label: string; // Note title
      connections: number; // Number of links
      cluster?: string; // For grouped nodes
    }

    export interface GraphEdge {
      source: string; // From note path
      target: string; // To note path
      type: 'link' | 'backlink' | 'embed';
    }

    export interface VaultGraph {
      nodes: GraphNode[];
      edges: GraphEdge[];
      clusters?: Record<string, string[]>; // Grouped nodes
    }

    export interface DataviewQuery {
      type: 'TABLE' | 'LIST' | 'TASK' | 'CALENDAR';
      query: string;
      fields: string[];
      filters: DataviewFilter[];
      sort?: DataviewSort[];
    }

    export interface DataviewFilter {
      field: string;
      operator: '=' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'and' | 'or';
      value: any;
    }

    export interface DataviewSort {
      field: string;
      direction: 'asc' | 'desc';
    }

    export interface DataviewResult {
      rows: Record<string, any>[];
      metadata: {
        totalRows: number;
        queryTime: number;
      };
    }

    export interface VaultContext {
      currentNote: ObsidianNote;
      backlinks: ObsidianNote[];
      forwardLinks: ObsidianNote[];
      graph: VaultGraph;
      dataviewResults?: DataviewResult[];
    }
    ```

    DO NOT implement Obsidian's dataview fully - just parse common queries.
  </action>
  <verify>types.ts exports ObsidianNote, GraphNode, GraphEdge, VaultGraph, VaultContext</verify>
  <done>Type definitions for vault context</done>
</task>

<task type="auto">
  <name>Implement markdown file parser</name>
  <files>packages/ai/src/vaultParser.ts</files>
  <action>
    Create `packages/ai/src/vaultParser.ts`:

    ```typescript
    import { readFile, readdir } from 'fs/promises';
    import { join, dirname, basename } from 'path';
    import { parse as parseYAML } from 'js-yaml';

    import type {
      ObsidianNote,
      InternalLink,
      GraphNode,
      GraphEdge,
      VaultGraph,
      DataviewQuery,
      DataviewResult,
      VaultContext
    } from './types';

    const WIKI_LINK_REGEX = /\[\[([^\]]+)\](?:\|[^\]]+)?\]/g;
    const MD_LINK_REGEX = /\[([^\]]+)\]\(([^)]+)\)/g;
    const TAG_REGEX = /#([\w-]+)/g;
    const EMBED_REGEX = /!\[\[([^\]]+)\](?:\|[^\]]+)?\]/g;

    export async function parseVault(
      vaultPath: string,
      currentNotePath: string
    ): Promise<VaultContext> {
      // Get all markdown files
      const notes = await getAllMarkdownFiles(vaultPath);

      // Parse current note
      const currentNote = await parseNote(currentNotePath, notes);

      // Build graph
      const graph = buildGraph(notes);

      // Get backlinks (notes that link to current note)
      const backlinks = notes.filter(note =>
        note.links.some(link =>
          link.target === currentNote.title ||
          link.target === currentNote.path
        )
      );

      // Get forward links (notes linked from current note)
      const forwardLinks = await Promise.all(
        currentNote.links
          .filter(link => link.type !== 'embed')
          .map(link => resolveLink(link, notes))
      );

      return {
        currentNote,
        backlinks,
        forwardLinks,
        graph,
      };
    }

    async function getAllMarkdownFiles(vaultPath: string): Promise<ObsidianNote[]> {
      const files = await readdir(vaultPath, { recursive: true });
      const mdFiles = files.filter(f => f.endsWith('.md'));

      const notes: ObsidianNote[] = [];

      for (const file of mdFiles) {
        try {
          const note = await parseNote(join(vaultPath, file), []);
          notes.push(note);
        } catch {
          // Skip files that can't be parsed
        }
      }

      return notes;
    }

    async function parseNote(
      filePath: string,
      allNotes: ObsidianNote[]
    ): Promise<ObsidianNote> {
      const content = await readFile(filePath, 'utf-8');
      const lines = content.split('\n');

      // Extract frontmatter
      let frontmatter: Record<string, any> = {};
      let contentStart = 0;

      if (lines[0] === '---') {
        const endIdx = lines.indexOf('---', 1);
        if (endIdx > 0) {
          const fmText = lines.slice(1, endIdx).join('\n');
          try {
            frontmatter = parseYAML(fmText) as Record<string, any>;
          } catch {
            // Invalid YAML, use empty
          }
          contentStart = endIdx + 1;
        }
      }

      // Extract links
      const links: InternalLink[] = [];
      const noteContent = lines.slice(contentStart).join('\n');

      // Wiki-style links [[note]]
      let match;
      while ((match = WIKI_LINK_REGEX.exec(noteContent)) !== null) {
        links.push({
          target: match[1],
          type: 'wiki',
          position: { line: 0, col: match.index }, // Simplified
        });
      }

      // Markdown links [text](path.md)
      while ((match = MD_LINK_REGEX.exec(noteContent)) !== null) {
        if (match[2].endsWith('.md')) {
          links.push({
            target: match[2],
            type: 'markdown',
          });
        }
      }

      // Embeds ![[note]]
      while ((match = EMBED_REGEX.exec(noteContent)) !== null) {
        links.push({
          target: match[1],
          type: 'embed',
        });
      }

      // Extract tags
      const tags: string[] = [];
      while ((match = TAG_REGEX.exec(noteContent)) !== null) {
        tags.push(match[1]);
      }

      // Get file stats
      const stats = await import('fs/promises').then(fs => fs.stat(filePath));

      return {
        path: filePath,
        title: basename(filePath, '.md'),
        content: noteContent,
        tags,
        frontmatter,
        links,
        backlinks: [], // Populated later
        created: stats.birthtime,
        modified: stats.mtime,
      };
    }

    function buildGraph(notes: ObsidianNote[]): VaultGraph {
      const nodes: GraphNode[] = notes.map(note => ({
        id: note.path,
        label: note.title,
        connections: note.links.length,
      }));

      const edges: GraphEdge[] = [];

      for (const note of notes) {
        for (const link of note.links) {
          // Find target note
          const target = notes.find(n =>
            n.title === link.target ||
            n.path.endsWith(link.target)
          );

          if (target) {
            edges.push({
              source: note.path,
              target: target.path,
              type: link.type === 'embed' ? 'embed' : 'link',
            });
          }
        }
      }

      return { nodes, edges };
    }

    async function resolveLink(
      link: InternalLink,
      notes: ObsidianNote[]
    ): Promise<ObsidianNote> {
      const note = notes.find(n =>
        n.title === link.target ||
        n.path.endsWith(link.target)
      );

      if (!note) {
        throw new Error(`Note not found: ${link.target}`);
      }

      return note;
    }

    export function getBacklinks(context: VaultContext): ObsidianNote[] {
      return context.backlinks;
    }

    export function getGraph(context: VaultContext): VaultGraph {
      return context.graph;
    }

    // Dataview query parser (simplified)
    export function parseDataview(query: string): DataviewQuery {
      // Very basic parser for common queries
      // TABLE field1, field2 FROM "folder"
      // LIST FROM #tag
      // TASK WHERE due <= today

      const upperQuery = query.trim().toUpperCase();

      let type: DataviewQuery['type'] = 'TABLE';
      if (upperQuery.startsWith('LIST')) type = 'LIST';
      if (upperQuery.startsWith('TASK')) type = 'TASK';
      if (upperQuery.startsWith('CALENDAR')) type = 'CALENDAR';

      // Extract fields (simplified)
      const fieldsMatch = query.match(/(?:TABLE|LIST)\s+([^FROM]+)/i);
      const fields = fieldsMatch
        ? fieldsMatch[1].split(',').map(f => f.trim())
        : ['file.name'];

      return {
        type,
        query,
        fields,
        filters: [],
      };
    }

    export async function executeDataview(
      query: DataviewQuery,
      context: VaultContext
    ): Promise<DataviewResult> {
      const start = Date.now();

      // Very basic execution - just return matching notes
      let rows = context.currentNote.frontmatter
        ? [context.currentNote.frontmatter]
        : [];

      // Apply filters (placeholder)
      // TODO: Implement actual filtering logic

      return {
        rows,
        metadata: {
          totalRows: rows.length,
          queryTime: Date.now() - start,
        },
      };
    }
    ```

    Use fs/promises for async file operations.

    DO NOT implement full dataview - just common query patterns.
  </action>
  <verify>vaultParser.ts exports parseVault, getBacklinks, getGraph, parseDataview</verify>
  <done>Vault parser with backlinks and graph support</done>
</task>

<task type="auto">
  <name>Create vault context UI component</name>
  <files>apps/portal/src/components/VaultContextPanel.tsx</files>
  <action>
    Create `apps/portal/src/components/VaultContextPanel.tsx`:

    ```typescript
    import React, { useState, useEffect } from 'react';
    import { parseVault, getBacklinks, getGraph } from '@obsidian-note-reviewer/ai/vaultParser';
    import type { VaultContext, ObsidianNote } from '@obsidian-note-reviewer/ai/types';

    interface VaultContextPanelProps {
      vaultPath: string;
      currentNotePath: string;
    }

    export function VaultContextPanel({
      vaultPath,
      currentNotePath
    }: VaultContextPanelProps) {
      const [context, setContext] = useState<VaultContext | null>(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [activeTab, setActiveTab] = useState<'backlinks' | 'graph'>('backlinks');

      useEffect(() => {
        setLoading(true);
        parseVault(vaultPath, currentNotePath)
          .then(setContext)
          .catch(err => setError(err.message))
          .finally(() => setLoading(false));
      }, [vaultPath, currentNotePath]);

      if (loading) return <div>Loading vault context...</div>;
      if (error) return <div>Error: {error}</div>;
      if (!context) return null;

      return (
        <div className="vault-context-panel">
          <div className="flex border-b">
            <button
              className={`px-4 py-2 ${activeTab === 'backlinks' ? 'border-b-2 border-blue-500' : ''}`}
              onClick={() => setActiveTab('backlinks')}
            >
              Backlinks ({context.backlinks.length})
            </button>
            <button
              className={`px-4 py-2 ${activeTab === 'graph' ? 'border-b-2 border-blue-500' : ''}`}
              onClick={() => setActiveTab('graph')}
            >
              Graph ({context.graph.nodes.length})
            </button>
          </div>

          {activeTab === 'backlinks' && (
            <BacklinksList backlinks={context.backlinks} />
          )}

          {activeTab === 'graph' && (
            <GraphView graph={context.graph} />
          )}
        </div>
      );
    }

    function BacklinksList({ backlinks }: { backlinks: ObsidianNote[] }) {
      if (backlinks.length === 0) {
        return <div className="p-4 text-gray-500">No backlinks found</div>;
      }

      return (
        <div className="p-4">
          <h4 className="font-semibold mb-2">Notes linking here</h4>
          <ul className="space-y-2">
            {backlinks.map(note => (
              <li key={note.path} className="text-sm">
                <a href={`obsidian://open?vault=${note.path}`} className="text-blue-600 hover:underline">
                  {note.title}
                </a>
                <span className="text-gray-400 ml-2">
                  {note.tags.map(t => `#${t}`).join(' ')}
                </span>
              </li>
            ))}
          </ul>
        </div>
      );
    }

    function GraphView({ graph }: { graph: any }) {
      return (
        <div className="p-4">
          <h4 className="font-semibold mb-2">Vault Graph</h4>
          <div className="text-sm">
            <p>Nodes: {graph.nodes.length}</p>
            <p>Edges: {graph.edges.length}</p>
            {/* TODO: Add actual graph visualization */}
          </div>
        </div>
      );
    }
    ```

    Use tabs for backlinks vs graph view.

    DO NOT implement full graph visualization - just counts for now.
  </action>
  <verify>VaultContextPanel.tsx displays backlinks and graph info</verify>
  <done>UI component for vault context</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete vault parser with backlink extraction, graph mapping, and UI display</what-built>
  <how-to-verify>
    Testing:

    1. Create test Obsidian vault with linked notes:
       - Note A links to Note B via [[Note B]]
       - Note C links to Note A
       - Note B has tags #important #todo

    2. Start portal: `cd apps/portal && bun run dev`
    3. Open Note A for review
    4. Verify vault context panel appears
    5. Check backlinks tab shows Note C
    6. Check graph tab shows correct counts
    7. Verify links are clickable (open in Obsidian)

    Expected outcomes:
    - All markdown files in vault are parsed
    - Wiki-style [[links]] are extracted
    - Backlinks correctly identify notes linking to current note
    - Graph shows accurate node/edge counts
  </how-to-verify>
  <resume-signal>Type "approved" if vault parsing works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] Vault context types defined (ObsidianNote, GraphNode, VaultGraph, etc)
- [ ] parseVault() reads and parses markdown files
- [ ] Wiki-style [[links]] are extracted
- [ ] Backlinks are correctly identified
- [ ] Graph is built with nodes and edges
- [ ] Dataview queries can be parsed
- [ ] UI component displays backlinks and graph info
- [ ] E2E test confirms complete workflow
</verification>

<success_criteria>
1. Vault parser reads Obsidian markdown files (AI-02 complete)
2. Backlinks are extracted from wiki-style links
3. Graph relationships are mapped between notes
4. UI displays vault context information
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-ai/plans/04-02-SUMMARY.md`
</output>

---

**Plan created:** 2026-02-05
**Estimated duration:** 25 min
**Complexity:** Medium (file system parsing)
