---
phase: 04-advanced-ai
plan: 01
type: execute
wave: 1
depends_on: ["03-05"]
files_modified:
  - packages/ai/src/suggester.ts
  - packages/ai/src/types.ts
  - packages/ai/src/config.ts
  - apps/portal/src/components/AISuggestions.tsx
  - apps/hook/server/index.ts
autonomous: false

must_haves:
  truths:
    - "AI suggestions are generated using Claude API"
    - "User can accept, modify, or reject each suggestion"
    - "Suggestions are typed (DELETION, REPLACEMENT, COMMENT)"
    - "Configuration controls suggestion sensitivity"
  artifacts:
    - path: "packages/ai/src/suggester.ts"
      provides: "AI suggestion engine with Claude API"
      exports: ["generateSuggestions", "acceptSuggestion", "rejectSuggestion"]
      min_lines: 200
    - path: "packages/ai/src/config.ts"
      provides: "AI configuration management"
      exports: ["getAIConfig", "updateAIConfig"]
    - path: "apps/portal/src/components/AISuggestions.tsx"
      provides: "UI for displaying and managing AI suggestions"
      min_lines: 150
  key_links:
    - from: "apps/portal/src/components/AISuggestions.tsx"
      to: "packages/ai/src/suggester.ts"
      via: "import"
      pattern: "generateSuggestions"
    - from: "apps/portal/src/components/AISuggestions.tsx"
      to: "packages/ui/store/useAnnotationStore.ts"
      via: "import"
      pattern: "addAnnotation"
---

<objective>
Implement AI-powered annotation suggestions using Claude API to proactively identify potential issues in plans and documents.

**Purpose:** Deliver AI-01 requirement - AI suggests annotations proactively by analyzing content for improvements, errors, and clarifications needed.

**Output:** Complete AI suggestion system with Claude API integration, user controls, and configurable behavior.
</objective>

<context>
@.planning/phases/03-claude-code-integration/03-CONTEXT.md
@packages/ui/types/index.ts
@packages/ui/store/useAnnotationStore.ts

# Existing patterns
@apps/portal/src/components/PromptEditor.tsx
@packages/api/routes/claude.ts
</context>

<tasks>

<task type="auto">
  <name>Create AI package structure</name>
  <files>packages/ai/</files>
  <action>
    Create new package structure for AI features:

    1. **Create package.json** - `packages/ai/package.json`:
       ```json
       {
         "name": "@obsidian-note-reviewer/ai",
         "version": "0.2.1",
         "type": "module",
         "exports": {
           "./suggester": "./src/suggester.ts",
           "./config": "./src/config.ts",
           "./types": "./src/types.ts"
         },
         "dependencies": {
           "@anthropic-ai/sdk": "^0.32.0",
           "@obsidian-note-reviewer/ui": "workspace:*"
         }
       }
       ```

    2. **Create directory structure**:
       - packages/ai/src/
       - packages/ai/__tests__/

    3. **Create tsconfig.json** extending root config

    Update root package.json workspaces if needed.

    DO NOT implement logic yet - just structure.
  </action>
  <verify>packages/ai/package.json exists with correct exports</verify>
  <done>AI package structure ready for implementation</done>
</task>

<task type="auto">
  <name>Define AI types</name>
  <files>packages/ai/src/types.ts</files>
  <action>
    Create `packages/ai/src/types.ts` with:

    ```typescript
    import { AnnotationType } from '@obsidian-note-reviewer/ui/types';

    export interface AISuggestion {
      id: string;
      type: 'deletion' | 'replacement' | 'comment';
      confidence: number; // 0-1
      reason: string; // Why AI suggested this
      targetText: string;
      suggestedText?: string; // For replacements
      lineStart?: number;
      lineEnd?: number;
    }

    export interface SuggestionConfig {
      enabled: boolean;
      sensitivity: 'low' | 'medium' | 'high';
      maxSuggestions: number;
      suggestionTypes: Array<'deletion' | 'replacement' | 'comment'>;
      apiKey?: string;
    }

    export interface SuggestionResult {
      suggestions: AISuggestion[];
      model: string;
      tokensUsed: number;
    }
    ```

    Use TypeScript for type safety.

    DO NOT import from Anthropic SDK directly - keep it decoupled.
  </action>
  <verify>types.ts exports AISuggestion, SuggestionConfig, SuggestionResult</verify>
  <done>Type definitions for AI suggestions</done>
</task>

<task type="auto">
  <name>Implement AI suggestion engine</name>
  <files>packages/ai/src/suggester.ts</files>
  <action>
    Create `packages/ai/src/suggester.ts`:

    ```typescript
    import Anthropic from '@anthropic-ai/sdk';
    import type { AISuggestion, SuggestionConfig, SuggestionResult } from './types';

    const DEFAULT_MODEL = 'claude-3-5-sonnet-20241022';

    export async function generateSuggestions(
      content: string,
      config: SuggestionConfig
    ): Promise<SuggestionResult> {
      if (!config.apiKey) {
        throw new Error('Anthropic API key required');
      }

      const anthropic = new Anthropic({ apiKey: config.apiKey });

      const systemPrompt = buildSystemPrompt(config);
      const userPrompt = buildUserPrompt(content, config);

      const response = await anthropic.messages.create({
        model: DEFAULT_MODEL,
        system: systemPrompt,
        messages: [{ role: 'user', content: userPrompt }],
        max_tokens: 4096,
        temperature: 0.3, // Lower for more consistent suggestions
      });

      const suggestions = parseSuggestions(response.content[0].type === 'text'
        ? response.content[0].text
        : ''
      );

      return {
        suggestions: suggestions.slice(0, config.maxSuggestions),
        model: response.model,
        tokensUsed: response.usage.input_tokens + response.usage.output_tokens,
      };
    }

    function buildSystemPrompt(config: SuggestionConfig): string {
      const enabledTypes = config.suggestionTypes.join(', ');
      return `You are a code and document reviewer. Analyze the content and suggest improvements.

Suggestion types: ${enabledTypes}
Sensitivity: ${config.sensitivity}

For each suggestion, provide:
- type: (deletion|replacement|comment)
- targetText: exact text to modify
- suggestedText: replacement text (for replacements)
- reason: why this change is recommended
- confidence: 0.0-1.0

Respond as JSON array.`;
    }

    function buildUserPrompt(content: string, config: SuggestionConfig): string {
      return `Analyze this content for improvements:\n\n${content}`;
    }

    function parseSuggestions(text: string): AISuggestion[] {
      // Extract JSON from response
      const jsonMatch = text.match(/\[[\s\S]*\]/);
      if (!jsonMatch) return [];

      try {
        const parsed = JSON.parse(jsonMatch[0]);
        return parsed.map((s: any, i: number) => ({
          id: `ai-sugg-${Date.now()}-${i}`,
          type: s.type,
          confidence: s.confidence ?? 0.7,
          reason: s.reason,
          targetText: s.targetText,
          suggestedText: s.suggestedText,
        }));
      } catch {
        return [];
      }
    }

    export async function acceptSuggestion(
      suggestion: AISuggestion,
      content: string
    ): Promise<string> {
      // Apply suggestion to content
      // Return modified content
    }

    export async function rejectSuggestion(
      suggestionId: string
    ): Promise<void> {
      // Log rejection for learning (future)
    }
    ```

    Implement error handling for API failures.

    DO NOT cache results - implement in next task.
  </action>
  <verify>suggester.ts exports generateSuggestions, acceptSuggestion, rejectSuggestion</verify>
  <done>AI suggestion engine with Claude API</done>
</task>

<task type="auto">
  <name>Implement configuration management</name>
  <files>packages/ai/src/config.ts</files>
  <action>
    Create `packages/ai/src/config.ts`:

    ```typescript
    import type { SuggestionConfig } from './types';

    const STORAGE_KEY = 'obsreview-ai-config';

    const DEFAULT_CONFIG: SuggestionConfig = {
      enabled: true,
      sensitivity: 'medium',
      maxSuggestions: 10,
      suggestionTypes: ['replacement', 'comment'],
    };

    export function getAIConfig(): SuggestionConfig {
      if (typeof window === 'undefined') return DEFAULT_CONFIG;

      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        return stored ? { ...DEFAULT_CONFIG, ...JSON.parse(stored) } : DEFAULT_CONFIG;
      } catch {
        return DEFAULT_CONFIG;
      }
    }

    export function updateAIConfig(updates: Partial<SuggestionConfig>): SuggestionConfig {
      const current = getAIConfig();
      const updated = { ...current, ...updates };

      if (typeof window !== 'undefined') {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
      }

      return updated;
    }

    export function setAPIKey(apiKey: string): void {
      updateAIConfig({ apiKey });
    }

    export function getAPIKey(): string | undefined {
      return getAIConfig().apiKey;
    }
    ```

    Use localStorage for persistence.

    DO NOT store API key in plain text - consider encryption in production.
  </action>
  <verify>config.ts exports getAIConfig, updateAIConfig, setAPIKey, getAPIKey</verify>
  <done>Configuration management with localStorage persistence</done>
</task>

<task type="auto">
  <name>Create AI suggestions UI component</name>
  <files>apps/portal/src/components/AISuggestions.tsx</files>
  <action>
    Create `apps/portal/src/components/AISuggestions.tsx`:

    ```typescript
    import React, { useState, useEffect } from 'react';
    import { generateSuggestions, acceptSuggestion, rejectSuggestion } from '@obsidian-note-reviewer/ai/suggester';
    import { getAIConfig } from '@obsidian-note-reviewer/ai/config';
    import type { AISuggestion } from '@obsidian-note-reviewer/ai/types';
    import type { Annotation } from '@obsidian-note-reviewer/ui/types';

    interface AISuggestionsProps {
      content: string;
      onAcceptSuggestion: (annotation: Annotation) => void;
    }

    export function AISuggestions({ content, onAcceptSuggestion }: AISuggestionsProps) {
      const [suggestions, setSuggestions] = useState<AISuggestion[]>([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const config = getAIConfig();

      useEffect(() => {
        if (!config.enabled || !config.apiKey) return;

        setLoading(true);
        generateSuggestions(content, config)
          .then(result => setSuggestions(result.suggestions))
          .catch(err => setError(err.message))
          .finally(() => setLoading(false));
      }, [content, config.enabled]);

      if (!config.enabled) return null;
      if (loading) return <div className="animate-pulse">AI analyzing...</div>;
      if (error) return <div className="text-red-500">Error: {error}</div>;
      if (suggestions.length === 0) return <div>No suggestions</div>;

      return (
        <div className="ai-suggestions">
          <h3>AI Suggestions ({suggestions.length})</h3>
          {suggestions.map(s => (
            <SuggestionItem
              key={s.id}
              suggestion={s}
              onAccept={() => handleAccept(s)}
              onReject={() => handleReject(s.id)}
            />
          ))}
        </div>
      );
    }

    function SuggestionItem({
      suggestion,
      onAccept,
      onReject
    }: {
      suggestion: AISuggestion;
      onAccept: () => void;
      onReject: () => void;
    }) {
      return (
        <div className="suggestion-item border-l-4 border-blue-500 p-3 mb-2">
          <div className="flex justify-between items-start">
            <div className="flex-1">
              <span className="text-xs uppercase">{suggestion.type}</span>
              <p className="text-sm">{suggestion.reason}</p>
              {suggestion.targetText && (
                <code className="text-xs bg-gray-100 p-1 rounded">
                  {suggestion.targetText}
                </code>
              )}
              {suggestion.suggestedText && (
                <code className="text-xs bg-green-100 p-1 rounded ml-1">
                  → {suggestion.suggestedText}
                </code>
              )}
              <div className="text-xs text-gray-500">
                Confidence: {Math.round(suggestion.confidence * 100)}%
              </div>
            </div>
            <div className="flex gap-2">
              <button onClick={onAccept} className="text-green-600">✓</button>
              <button onClick={onReject} className="text-red-600">✗</button>
            </div>
          </div>
        </div>
      );
    }

    function handleAccept(suggestion: AISuggestion) {
      // Convert to Annotation and call onAcceptSuggestion
      const annotation: Annotation = {
        id: `ai-${suggestion.id}`,
        blockId: '',
        createdA: Date.now(),
        type: mapToAnnotationType(suggestion.type),
        text: suggestion.suggestedText || suggestion.reason,
        originalText: suggestion.targetText,
      };
      onAcceptSuggestion(annotation);
      setSuggestions(prev => prev.filter(s => s.id !== suggestion.id));
    }

    function handleReject(id: string) {
      rejectSuggestion(id);
      setSuggestions(prev => prev.filter(s => s.id !== id));
    }

    function mapToAnnotationType(type: string): any {
      // Map AI suggestion type to AnnotationType
    }
    ```

    Use Tailwind CSS for styling.

    DO NOT implement auto-apply - user must always accept.
  </action>
  <verify>AISuggestions.tsx renders suggestions with accept/reject buttons</verify>
  <done>UI component for AI suggestions</done>
</task>

<task type="auto">
  <name>Add API endpoint for hook mode</name>
  <files>apps/hook/server/index.ts</files>
  <action>
    Update `apps/hook/server/index.ts` to add AI suggestions endpoint:

    ```typescript
    // API: Get AI suggestions
    if (url.pathname === "/api/ai-suggestions" && req.method === "POST") {
      try {
        const body = await req.json() as { content: string; config?: any };
        const aiConfig = body.config || getAIConfig(); // Import from config

        if (!aiConfig.apiKey) {
          return Response.json(
            { ok: false, error: "API key required" },
            { status: 400, headers: getSecurityHeaders() }
          );
        }

        const result = await generateSuggestions(noteContent, aiConfig);
        return Response.json(
          { ok: true, suggestions: result.suggestions },
          { headers: getSecurityHeaders() }
        );
      } catch (error) {
        return Response.json(
          { ok: false, error: error.message },
          { status: 500, headers: getSecurityHeaders() }
        );
      }
    }
    ```

    Import generateSuggestions from @obsidian-note-reviewer/ai/suggester.

    DO NOT block main thread - use async properly.
  </action>
  <verify>Server has POST /api/ai-suggestions endpoint</verify>
  <done>Hook mode can request AI suggestions</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete AI suggestion system with Claude API integration, UI component, and configuration management</what-built>
  <how-to-verify>
    End-to-end testing:

    1. Set up Anthropic API key in config
    2. Start portal: `cd apps/portal && bun run dev`
    3. Open a document for review
    4. Verify AI suggestions appear in sidebar
    5. Test accepting a suggestion - should create annotation
    6. Test rejecting a suggestion - should remove from list
    7. Test with different sensitivity settings
    8. Test with different suggestion types enabled

    Expected outcomes:
    - AI suggestions generated within 5 seconds
    - Each suggestion has type, confidence, reason
    - Accept button creates annotation in store
    - Reject button removes suggestion
    - Config changes persist across reload
  </how-to-verify>
  <resume-signal>Type "approved" if AI suggestions work correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] AI package created with proper structure
- [ ] Types defined for AISuggestion, SuggestionConfig, SuggestionResult
- [ ] generateSuggestions() calls Claude API and returns suggestions
- [ ] Configuration persists to localStorage
- [ ] UI component displays suggestions with accept/reject
- [ ] Hook server has /api/ai-suggestions endpoint
- [ ] E2E test confirms complete workflow
</verification>

<success_criteria>
1. AI generates suggestions using Claude API (AI-01 complete)
2. User can accept, modify, or reject each suggestion
3. Configuration controls sensitivity and suggestion types
4. Suggestions are typed (deletion, replacement, comment)
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-ai/plans/04-01-SUMMARY.md`
</output>

---

**Plan created:** 2026-02-05
**Estimated duration:** 35 min
**Complexity:** Medium (Claude API integration)
