---
phase: 04-advanced-ai
plan: 03
type: execute
wave: 3
depends_on: ["04-01"]
files_modified:
  - packages/ai/src/summarizer.ts
  - packages/ai/src/types.ts
  - apps/portal/src/components/SummaryPanel.tsx
  - apps/hook/server/index.ts
autonomous: false

must_haves:
  truths:
    - "AI generates executive summaries from annotated documents"
    - "Summaries respect annotation context (highlights critical feedback)"
    - "Multiple export formats supported (text, markdown, JSON)"
    - "Summary includes annotation count and type breakdown"
  artifacts:
    - path: "packages/ai/src/summarizer.ts"
      provides: "AI summarizer with annotation awareness"
      exports: ["generateSummary", "exportSummary"]
      min_lines: 180
    - path: "apps/portal/src/components/SummaryPanel.tsx"
      provides: "UI component for AI summaries"
      min_lines: 100
  key_links:
    - from: "packages/ai/src/summarizer.ts"
      to: "packages/ui/utils/claudeExport.ts"
      via: "import"
      pattern: "exportForClaude"
    - from: "apps/portal/src/components/SummaryPanel.tsx"
      to: "packages/ai/src/summarizer.ts"
      via: "import"
      pattern: "generateSummary"
---

<objective>
Create AI-powered summarization that generates executive summaries from annotated documents, incorporating annotation context and highlighting critical feedback.

**Purpose:** Deliver AI-03 requirement - AI generates executive summaries of annotated documents that respect annotation context and highlight important areas.

**Output:** Complete summarization system with Claude API integration, annotation awareness, and multi-format export.
</objective>

<context>
@.planning/phases/04-advanced-ai/04-01-PLAN.md
@.planning/phases/03-claude-code-integration/03-CONTEXT.md
@packages/ui/utils/claudeExport.ts
@packages/ui/types/index.ts

# Existing patterns
@packages/ui/utils/claudeExport.ts
</context>

<tasks>

<task type="auto">
  <name>Define summarizer types</name>
  <files>packages/ai/src/types.ts</files>
  <action>
    Add to `packages/ai/src/types.ts`:

    ```typescript
    export interface SummaryRequest {
      documentContent: string;
      annotations: Annotation[];
      includeAnnotations: boolean;
      maxLength?: number;
      style: 'executive' | 'detailed' | 'bullet-points';
    }

    export interface DocumentSummary {
      title: string;
      overview: string;
      keyPoints: string[];
      annotationHighlights: AnnotationHighlight[];
      recommendation?: string;
      metadata: SummaryMetadata;
    }

    export interface AnnotationHighlight {
      count: number;
      byType: Record<string, number>;
      criticalIssues: string[];
      suggestedImprovements: string[];
      questionsRaised: string[];
    }

    export interface SummaryMetadata {
      generatedAt: string;
      documentLength: number;
      annotationCount: number;
      model: string;
      tokensUsed: number;
    }

    export type SummaryFormat = 'text' | 'markdown' | 'json';

    export interface SummaryExport {
      format: SummaryFormat;
      content: string;
      filename: string;
    }
    ```

    Extend existing types file.

    DO NOT duplicate Annotation type - import from @obsidian-note-reviewer/ui/types.
  </action>
  <verify>types.ts exports SummaryRequest, DocumentSummary, AnnotationHighlight</verify>
  <done>Summarizer type definitions</done>
</task>

<task type="auto">
  <name>Implement AI summarizer</name>
  <files>packages/ai/src/summarizer.ts</files>
  <action>
    Create `packages/ai/src/summarizer.ts`:

    ```typescript
    import Anthropic from '@anthropic-ai/sdk';
    import { exportForClaude } from '@obsidian-note-reviewer/ui/utils/claudeExport';
    import type { Annotation } from '@obsidian-note-reviewer/ui/types';
    import type {
      SummaryRequest,
      DocumentSummary,
      AnnotationHighlight,
      SummaryMetadata,
      SummaryExport,
      SummaryFormat
    } from './types';
    import { getAIConfig } from './config';

    const DEFAULT_MODEL = 'claude-3-5-sonnet-20241022';

    export async function generateSummary(
      request: SummaryRequest
    ): Promise<DocumentSummary> {
      const config = getAIConfig();
      if (!config.apiKey) {
        throw new Error('Anthropic API key required');
      }

      const anthropic = new Anthropic({ apiKey: config.apiKey });

      // Get annotation context
      const annotationContext = request.includeAnnotations
        ? buildAnnotationContext(request.annotations)
        : null;

      // Build prompt
      const systemPrompt = buildSummarySystemPrompt(request.style);
      const userPrompt = buildSummaryUserPrompt(
        request.documentContent,
        annotationContext,
        request.maxLength
      );

      const response = await anthropic.messages.create({
        model: DEFAULT_MODEL,
        system: systemPrompt,
        messages: [{ role: 'user', content: userPrompt }],
        max_tokens: 4096,
        temperature: 0.5,
      });

      const summaryText = response.content[0].type === 'text'
        ? response.content[0].text
        : '';

      const summary = parseSummaryResponse(summaryText, request);

      return {
        ...summary,
        annotationHighlights: buildAnnotationHighlights(request.annotations),
        metadata: {
          generatedAt: new Date().toISOString(),
          documentLength: request.documentContent.length,
          annotationCount: request.annotations.length,
          model: response.model,
          tokensUsed: response.usage.input_tokens + response.usage.output_tokens,
        },
      };
    }

    function buildAnnotationContext(annotations: Annotation[]): string {
      const exportData = exportForClaude(annotations);

      return `
Annotations context:
- Total: ${exportData.totalCount}
- Types: ${Object.entries(exportData.metadata.types)
  .filter(([_, count]) => count > 0)
  .map(([type, count]) => `${type}: ${count}`)
  .join(', ')}

Key annotations:
${exportData.annotations.slice(0, 10).map(a => {
  let text = `- ${a.type}`;
  if (a.comment) text += `: ${a.comment}`;
  if (a.originalText) text += ` ("${a.originalText}")`;
  return text;
}).join('\n')}
      `.trim();
    }

    function buildSummarySystemPrompt(style: string): string {
      const basePrompt = 'You are an expert document summarizer.';

      const styleInstructions = {
        executive: 'Create a concise executive summary (2-3 paragraphs max) focusing on key insights and actionable items.',
        detailed: 'Create a detailed summary with section-by-section breakdown and comprehensive analysis.',
        'bullet-points': 'Create a structured summary using bullet points for easy scanning.',
      };

      return `${basePrompt}\n\n${styleInstructions[style]}\n\nIf annotations are provided, incorporate them into the summary and highlight critical areas.`;
    }

    function buildSummaryUserPrompt(
      content: string,
      annotationContext: string | null,
      maxLength?: number
    ): string {
      let prompt = `Please summarize the following document:\n\n${content}`;

      if (annotationContext) {
        prompt += `\n\n${annotationContext}\n\nEnsure the summary reflects the feedback and issues raised in these annotations.`;
      }

      if (maxLength) {
        prompt += `\n\nKeep the summary under ${maxLength} characters.`;
      }

      return prompt;
    }

    function parseSummaryResponse(text: string, request: SummaryRequest): Omit<DocumentSummary, 'metadata' | 'annotationHighlights'> {
      // Parse structured response from Claude
      // Claude should return JSON with title, overview, keyPoints, recommendation

      const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/) ||
                       text.match(/\{[\s\S]*\}/);

      if (!jsonMatch) {
        // Fallback to plain text
        return {
          title: 'Summary',
          overview: text.slice(0, 500),
          keyPoints: [],
        };
      }

      try {
        const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
        return {
          title: parsed.title || 'Document Summary',
          overview: parsed.overview || '',
          keyPoints: parsed.keyPoints || [],
          recommendation: parsed.recommendation,
        };
      } catch {
        return {
          title: 'Summary',
          overview: text.slice(0, 500),
          keyPoints: [],
        };
      }
    }

    function buildAnnotationHighlights(annotations: Annotation[]): AnnotationHighlight {
      const byType: Record<string, number> = {};
      const criticalIssues: string[] = [];
      const suggestedImprovements: string[] = [];
      const questionsRaised: string[] = [];

      for (const ann of annotations) {
        // Count by type
        const typeName = ann.type;
        byType[typeName] = (byType[typeName] || 0) + 1;

        // Categorize by type
        if (ann.type === 'DELETION' || ann.status === 'open') {
          if (ann.text) {
            criticalIssues.push(ann.text);
          }
        } else if (ann.type === 'REPLACEMENT' || ann.type === 'INSERTION') {
          if (ann.text) {
            suggestedImprovements.push(ann.text);
          }
        } else if (ann.type === 'COMMENT') {
          if (ann.text) {
            questionsRaised.push(ann.text);
          }
        }
      }

      return {
        count: annotations.length,
        byType,
        criticalIssues: criticalIssues.slice(0, 5),
        suggestedImprovements: suggestedImprovements.slice(0, 5),
        questionsRaised: questionsRaised.slice(0, 5),
      };
    }

    export function exportSummary(
      summary: DocumentSummary,
      format: SummaryFormat
    ): SummaryExport {
      const filename = `summary-${Date.now()}`;
      let content: string;

      switch (format) {
        case 'markdown':
          content = formatAsMarkdown(summary);
          return {
            format,
            content,
            filename: `${filename}.md`,
          };

        case 'json':
          content = JSON.stringify(summary, null, 2);
          return {
            format,
            content,
            filename: `${filename}.json`,
          };

        case 'text':
        default:
          content = formatAsText(summary);
          return {
            format,
            content,
            filename: `${filename}.txt`,
          };
      }
    }

    function formatAsMarkdown(summary: DocumentSummary): string {
      const lines: string[] = [];

      lines.push(`# ${summary.title}\n`);
      lines.push(`*Generated: ${new Date(summary.metadata.generatedAt).toLocaleString('pt-BR')}*\n`);

      lines.push('## Overview\n');
      lines.push(summary.overview);

      if (summary.keyPoints.length > 0) {
        lines.push('\n## Key Points\n');
        for (const point of summary.keyPoints) {
          lines.push(`- ${point}`);
        }
      }

      if (summary.annotationHighlights.count > 0) {
        const h = summary.annotationHighlights;
        lines.push('\n## Annotation Highlights\n');
        lines.push(`- **Total annotations:** ${h.count}`);

        if (Object.keys(h.byType).length > 0) {
          lines.push('- **By type:**');
          for (const [type, count] of Object.entries(h.byType)) {
            lines.push(`  - ${type}: ${count}`);
          }
        }

        if (h.criticalIssues.length > 0) {
          lines.push('\n### Critical Issues');
          for (const issue of h.criticalIssues) {
            lines.push(`- ${issue}`);
          }
        }

        if (h.suggestedImprovements.length > 0) {
          lines.push('\n### Suggested Improvements');
          for (const imp of h.suggestedImprovements) {
            lines.push(`- ${imp}`);
          }
        }
      }

      if (summary.recommendation) {
        lines.push('\n## Recommendation\n');
        lines.push(summary.recommendation);
      }

      return lines.join('\n');
    }

    function formatAsText(summary: DocumentSummary): string {
      const lines: string[] = [];

      lines.push(summary.title.toUpperCase());
      lines.push('='.repeat(summary.title.length));
      lines.push('');
      lines.push(summary.overview);
      lines.push('');

      if (summary.keyPoints.length > 0) {
        lines.push('KEY POINTS:');
        for (const point of summary.keyPoints) {
          lines.push(`  â€¢ ${point}`);
        }
        lines.push('');
      }

      if (summary.annotationHighlights.count > 0) {
        lines.push(`ANNOTATIONS: ${summary.annotationHighlights.count} total`);
      }

      if (summary.recommendation) {
        lines.push(`\nRECOMMENDATION:\n  ${summary.recommendation}`);
      }

      return lines.join('\n');
    }
    ```

    Use exportForClaude from @obsidian-note-reviewer/ui/utils for annotation context.

    DO NOT generate summary without considering annotations.
  </action>
  <verify>summarizer.ts exports generateSummary, exportSummary</verify>
  <done>AI summarizer with annotation awareness</done>
</task>

<task type="auto">
  <name>Create summary panel UI</name>
  <files>apps/portal/src/components/SummaryPanel.tsx</files>
  <action>
    Create `apps/portal/src/components/SummaryPanel.tsx`:

    ```typescript
    import React, { useState } from 'react';
    import { generateSummary, exportSummary } from '@obsidian-note-reviewer/ai/summarizer';
    import type { DocumentSummary, SummaryFormat } from '@obsidian-note-reviewer/ai/types';
    import type { Annotation } from '@obsidian-note-reviewer/ui/types';

    interface SummaryPanelProps {
      documentContent: string;
      annotations: Annotation[];
    }

    export function SummaryPanel({ documentContent, annotations }: SummaryPanelProps) {
      const [summary, setSummary] = useState<DocumentSummary | null>(null);
      const [loading, setLoading] = useState(false);
      const [style, setStyle] = useState<'executive' | 'detailed' | 'bullet-points'>('executive');

      const handleGenerate = async () => {
        setLoading(true);
        try {
          const result = await generateSummary({
            documentContent,
            annotations,
            includeAnnotations: true,
            style,
          });
          setSummary(result);
        } catch (error) {
          console.error('Failed to generate summary:', error);
        } finally {
          setLoading(false);
        }
      };

      const handleExport = (format: SummaryFormat) => {
        if (!summary) return;

        const exported = exportSummary(summary, format);

        // Trigger download
        const blob = new Blob([exported.content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = exported.filename;
        a.click();
        URL.revokeObjectURL(url);
      };

      return (
        <div className="summary-panel p-4">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-semibold">AI Summary</h3>
            <div className="flex gap-2">
              <select
                value={style}
                onChange={(e) => setStyle(e.target.value as any)}
                className="border rounded px-2 py-1"
              >
                <option value="executive">Executive</option>
                <option value="detailed">Detailed</option>
                <option value="bullet-points">Bullet Points</option>
              </select>
              <button
                onClick={handleGenerate}
                disabled={loading}
                className="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 disabled:opacity-50"
              >
                {loading ? 'Generating...' : 'Generate'}
              </button>
            </div>
          </div>

          {summary && (
            <>
              <SummaryContent summary={summary} />

              <div className="mt-4 flex gap-2">
                <span className="text-sm text-gray-500">Export as:</span>
                <button
                  onClick={() => handleExport('markdown')}
                  className="text-blue-600 hover:underline text-sm"
                >
                  Markdown
                </button>
                <button
                  onClick={() => handleExport('json')}
                  className="text-blue-600 hover:underline text-sm"
                >
                  JSON
                </button>
                <button
                  onClick={() => handleExport('text')}
                  className="text-blue-600 hover:underline text-sm"
                >
                  Text
                </button>
              </div>
            </>
          )}
        </div>
      );
    }

    function SummaryContent({ summary }: { summary: DocumentSummary }) {
      return (
        <div className="space-y-4">
          <div>
            <h4 className="font-semibold">{summary.title}</h4>
            <p className="text-sm text-gray-500">
              Generated: {new Date(summary.metadata.generatedAt).toLocaleString('pt-BR')}
            </p>
          </div>

          <div>
            <h5 className="font-medium mb-2">Overview</h5>
            <p className="text-sm">{summary.overview}</p>
          </div>

          {summary.keyPoints.length > 0 && (
            <div>
              <h5 className="font-medium mb-2">Key Points</h5>
              <ul className="list-disc list-inside text-sm space-y-1">
                {summary.keyPoints.map((point, i) => (
                  <li key={i}>{point}</li>
                ))}
              </ul>
            </div>
          )}

          {summary.annotationHighlights.count > 0 && (
            <div className="bg-yellow-50 p-3 rounded">
              <h5 className="font-medium mb-2">Annotation Highlights</h5>
              <p className="text-sm">
                <strong>{summary.annotationHighlights.count}</strong> annotations
              </p>

              {summary.annotationHighlights.criticalIssues.length > 0 && (
                <div className="mt-2">
                  <p className="text-xs font-medium text-red-600">Critical Issues:</p>
                  <ul className="list-disc list-inside text-xs">
                    {summary.annotationHighlights.criticalIssues.map((issue, i) => (
                      <li key={i}>{issue}</li>
                    ))}
                  </ul>
                </div>
              )}

              {summary.annotationHighlights.suggestedImprovements.length > 0 && (
                <div className="mt-2">
                  <p className="text-xs font-medium text-green-600">Suggested Improvements:</p>
                  <ul className="list-disc list-inside text-xs">
                    {summary.annotationHighlights.suggestedImprovements.map((imp, i) => (
                      <li key={i}>{imp}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}

          {summary.recommendation && (
            <div className="bg-blue-50 p-3 rounded">
              <h5 className="font-medium mb-2">Recommendation</h5>
              <p className="text-sm">{summary.recommendation}</p>
            </div>
          )}

          <div className="text-xs text-gray-400">
            Model: {summary.metadata.model} |
            Tokens: {summary.metadata.tokensUsed}
          </div>
        </div>
      );
    }
    ```

    Add download functionality for exports.

    DO NOT auto-generate - user must click button.
  </action>
  <verify>SummaryPanel.tsx generates and displays summaries with export options</verify>
  <done>UI component for AI summaries</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete AI summarization system with annotation awareness and multi-format export</what-built>
  <how-to-verify>
    End-to-end testing:

    1. Create a document with several annotations
    2. Start portal: `cd apps/portal && bun run dev`
    3. Open document for review
    4. Go to Summary panel
    5. Click "Generate" button
    6. Verify summary includes:
       - Overview of document
       - Key points extracted
       - Annotation highlights (count by type)
       - Critical issues listed
    7. Test export as Markdown - verify file downloads
    8. Test export as JSON - verify structure
    9. Try different summary styles

    Expected outcomes:
    - Summary generates within 5 seconds
    - Annotation context is included in summary
    - Critical annotations are highlighted
    - Export files download correctly
    - Different styles produce appropriately formatted outputs
  </how-to-verify>
  <resume-signal>Type "approved" if summarization works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] Summarizer types defined (SummaryRequest, DocumentSummary, AnnotationHighlight)
- [ ] generateSummary() calls Claude API with annotation context
- [ ] buildAnnotationContext() uses exportForClaude for context
- [ ] Summary includes annotation highlights (count, critical issues, improvements)
- [ ] exportSummary() supports text, markdown, JSON formats
- [ ] UI component generates and displays summaries
- [ ] Export buttons download files correctly
- [ ] E2E test confirms complete workflow
</verification>

<success_criteria>
1. AI generates executive summaries (AI-03 complete)
2. Summaries respect annotation context
3. Critical annotations are highlighted
4. Multiple export formats supported
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-ai/plans/04-03-SUMMARY.md`
</output>

---

**Plan created:** 2026-02-05
**Estimated duration:** 25 min
**Complexity:** Medium (Claude API integration with annotation context)
