---
phase: 01-authentication
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - app/welcome/page.tsx
  - components/auth/ProfileForm.tsx
  - lib/supabase/storage.ts
autonomous: false
user_setup:
  - service: supabase
    why: "Storage bucket configuration for avatars"
    dashboard_config:
      - task: "Create 'avatars' storage bucket"
        location: "Supabase Dashboard -> Storage -> New bucket"
      - task: "Set bucket to public"
        location: "Supabase Dashboard -> Storage -> avatars -> Configure"
      - task: "Add RLS policy for user uploads"
        location: "Supabase Dashboard -> Storage -> avatars -> Policies"

must_haves:
  truths:
    - "Welcome page appears after first signup with greeting using user's name"
    - "User can upload avatar image to Supabase Storage"
    - "User can set display name (REQUIRED field per locked decision)"
    - "Skip button allows bypassing profile completion (per locked decision)"
    - "Avatar upload stores in user-isolated folder in Supabase Storage"
    - "Avatar URL stored in user metadata"
  artifacts:
    - path: "app/welcome/page.tsx"
      provides: "Onboarding/welcome page"
      contains: "ProfileForm"
      min_lines: 20
    - path: "components/auth/ProfileForm.tsx"
      provides: "Profile completion form with avatar upload"
      contains: "'use client'"
      min_lines: 100
    - path: "lib/supabase/storage.ts"
      provides: "Storage utility functions for avatar upload"
      exports: ["uploadAvatar", "getAvatarUrl"]
      min_lines: 40
  key_links:
    - from: "components/auth/ProfileForm.tsx"
      to: "lib/supabase/storage.ts"
      via: "import uploadAvatar"
      pattern: "uploadAvatar"
    - from: "components/auth/ProfileForm.tsx"
      to: "lib/auth/hooks.ts"
      via: "import useAuth"
      pattern: "useAuth.*updateUser"
    - from: "app/welcome/page.tsx"
      to: "components/auth/ProfileForm.tsx"
      via: "import and render ProfileForm"
      pattern: "ProfileForm"
---

<objective>
Create welcome/onboarding page with profile completion form including avatar upload and display name. This is shown to users after first signup.

Purpose: Collect essential user information (display name and avatar) after signup. Per locked decision, display name and avatar are REQUIRED but skip button is available.

Output: Welcome page route, ProfileForm component with avatar upload, storage utilities.
</objective>

<execution_context>
@C:\Users\Alex\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Alex\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/phases/01-authentication/01-RESEARCH.md
@.planning/phases/01-authentication/01-01-PLAN.md
@.planning/phases/01-authentication/01-02-PLAN.md

# Locked decisions (from Phase Context):
- Signup → Welcome page
- Display name and avatar are REQUIRED during onboarding
- Welcome page has SKIP button available
- First login → Dashboard (no repeated onboarding)

# Research-based patterns:
- Supabase Storage for avatars (NOT Gravatar per Claude's discretion)
- Avatar upload with user-isolated folders
- RLS policies for security
- Store avatar_url in user metadata

# Claude's discretion (from research):
- Minimal welcome page with profile completion
- Hero section: "Welcome, [Name]!"
- Quick start CTA
- Skip button (can complete profile later)
</context>

<tasks>

<task type="auto">
  <name>Create storage utility for avatar upload</name>
  <files>lib/supabase/storage.ts</files>
  <action>
Create lib/supabase/storage.ts:

```typescript
import { createClient } from './client'

export async function uploadAvatar(userId: string, file: File): Promise<string> {
  const supabase = createClient()

  // Generate unique filename
  const fileExt = file.name.split('.').pop()
  const fileName = `${Math.random().toString(36).substring(2)}.${fileExt}`
  const filePath = `${userId}/${fileName}`

  // Upload to avatars bucket
  const { error: uploadError } = await supabase.storage
    .from('avatars')
    .upload(filePath, file)

  if (uploadError) {
    throw new Error(`Failed to upload avatar: ${uploadError.message}`)
  }

  // Get public URL
  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(filePath)

  return data.publicUrl
}

export async function updateAvatarUrl(avatarUrl: string): Promise<void> {
  const supabase = createClient()

  const { error } = await supabase.auth.updateUser({
    data: { avatar_url: avatarUrl }
  })

  if (error) {
    throw new Error(`Failed to update avatar URL: ${error.message}`)
  }
}

export function getAvatarUrl(user: any): string | null {
  return user?.user_metadata?.avatar_url || null
}
```

NOTES:
- Uses Supabase Storage (not Gravatar) per research recommendation
- User-isolated folders prevent conflicts
- Public URL for direct access
- Stores avatar_url in user metadata

REQUIRED: User must create 'avatars' bucket in Supabase Dashboard with:
1. Public bucket enabled
2. RLS policy allowing users to upload to their own folder
  </action>
  <verify>test -f lib/supabase/storage.ts && grep -q "uploadAvatar" lib/supabase/storage.ts && grep -q "getPublicUrl" lib/supabase/storage.ts</verify>
  <done>lib/supabase/storage.ts exports uploadAvatar, updateAvatarUrl, and getAvatarUrl functions</done>
</task>

<task type="auto">
  <name>Create ProfileForm component with avatar upload</name>
  <files>components/auth/ProfileForm.tsx</files>
  <action>
Create components/auth/ProfileForm.tsx:

```typescript
'use client'

import { useState, useRef, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { useAuth } from '@/lib/auth/hooks'
import { uploadAvatar, updateAvatarUrl } from '@/lib/supabase/storage'
import toast from 'react-hot-toast'

export function ProfileForm({ onComplete }: { onComplete?: () => void }) {
  const { user } = useAuth()
  const router = useRouter()
  const fileInputRef = useRef<HTMLInputElement>(null)

  const [displayName, setDisplayName] = useState('')
  const [avatarUrl, setAvatarUrl] = useState<string | null>(null)
  const [uploading, setUploading] = useState(false)
  const [loading, setLoading] = useState(false)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)

  useEffect(() => {
    // Load existing user data
    if (user) {
      setDisplayName(user.user_metadata?.full_name || user.user_metadata?.name || '')
      setAvatarUrl(user.user_metadata?.avatar_url || null)
    }
  }, [user])

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    // Validate file type
    if (!file.type.startsWith('image/')) {
      toast.error('Por favor, selecione um arquivo de imagem válido.')
      return
    }

    // Validate file size (max 2MB)
    if (file.size > 2 * 1024 * 1024) {
      toast.error('A imagem deve ter no máximo 2MB.')
      return
    }

    // Create preview
    const reader = new FileReader()
    reader.onloadend = () => {
      setPreviewUrl(reader.result as string)
    }
    reader.readAsDataURL(file)

    // Upload avatar
    setUploading(true)
    try {
      const publicUrl = await uploadAvatar(user!.id, file)
      setAvatarUrl(publicUrl)
      toast.success('Avatar enviado com sucesso!')
    } catch (error: any) {
      toast.error(error.message || 'Erro ao enviar avatar.')
      setPreviewUrl(null)
    } finally {
      setUploading(false)
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!displayName.trim()) {
      toast.error('Por favor, insira seu nome de exibição.')
      return
    }

    setLoading(true)

    try {
      // Update user metadata
      const { error } = await user!.update({
        data: {
          full_name: displayName.trim(),
          avatar_url: avatarUrl,
        },
      })

      if (error) throw error

      toast.success('Perfil atualizado com sucesso!')

      if (onComplete) {
        onComplete()
      } else {
        router.push('/dashboard')
      }
    } catch (error: any) {
      toast.error(error.message || 'Erro ao atualizar perfil.')
    } finally {
      setLoading(false)
    }
  }

  const handleSkip = () => {
    if (onComplete) {
      onComplete()
    } else {
      router.push('/dashboard')
    }
  }

  const displayAvatar = previewUrl || avatarUrl

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Avatar Upload */}
      <div className="flex flex-col items-center space-y-4">
        <div className="relative">
          {displayAvatar ? (
            <img
              src={displayAvatar}
              alt="Avatar"
              className="w-24 h-24 rounded-full object-cover border-2 border-border"
            />
          ) : (
            <div className="w-24 h-24 rounded-full bg-muted flex items-center justify-center border-2 border-border">
              <svg className="w-12 h-12 text-muted-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
            </div>
          )}
          {uploading && (
            <div className="absolute inset-0 rounded-full bg-background/80 flex items-center justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
            </div>
          )}
        </div>

        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleFileChange}
          className="hidden"
        />

        <button
          type="button"
          onClick={() => fileInputRef.current?.click()}
          disabled={uploading}
          className="text-sm text-primary hover:underline disabled:opacity-50"
        >
          {displayAvatar ? 'Alterar foto' : 'Adicionar foto'}
        </button>
        <p className="text-xs text-muted-foreground">JPG, PNG ou GIF. Máximo 2MB.</p>
      </div>

      {/* Display Name Input */}
      <div>
        <label htmlFor="displayName" className="block text-sm font-medium mb-1">
          Nome de exibição <span className="text-destructive">*</span>
        </label>
        <input
          id="displayName"
          type="text"
          value={displayName}
          onChange={(e) => setDisplayName(e.target.value)}
          required
          className="w-full px-3 py-2 border border-input rounded-md focus:outline-none focus:ring-2 focus:ring-ring"
          placeholder="Como você gostaria de ser chamado?"
        />
      </div>

      {/* Submit and Skip Buttons */}
      <div className="flex flex-col sm:flex-row gap-3">
        <button
          type="submit"
          disabled={loading || uploading}
          className="flex-1 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Salvando...' : 'Continuar'}
        </button>

        <button
          type="button"
          onClick={handleSkip}
          className="flex-1 px-4 py-2 border border-input rounded-md hover:bg-accent transition-colors"
        >
          Pular
        </button>
      </div>

      <p className="text-xs text-center text-muted-foreground">
        Você pode completar seu perfil a qualquer momento nas configurações.
      </p>
    </form>
  )
}
```

NOTES:
- Display name is REQUIRED (marked with * and validation)
- Avatar upload with preview and validation (type, size)
- Skip button available (per locked decision)
- Stores avatar_url and full_name in user metadata
- Max file size 2MB
  </action>
  <verify>test -f components/auth/ProfileForm.tsx && grep -q "uploadAvatar" components/auth/ProfileForm.tsx && grep -q "Pular" components/auth/ProfileForm.tsx</verify>
  <done>components/auth/ProfileForm.tsx renders profile form with avatar upload and display name input</done>
</task>

<task type="auto">
  <name>Create welcome page route</name>
  <files>app/welcome/page.tsx</files>
  <action>
Create app/welcome/page.tsx:

```typescript
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { ProfileForm } from '@/components/auth/ProfileForm'

export default async function WelcomePage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  // Redirect if not authenticated
  if (!user) {
    redirect('/auth/login')
  }

  // Check if user already completed onboarding
  const hasCompletedOnboarding = user.user_metadata?.full_name

  // If user already has display name, they've been here before
  // Redirect to dashboard to avoid repeated onboarding
  if (hasCompletedOnboarding) {
    redirect('/dashboard')
  }

  const displayName = user.user_metadata?.full_name || user.user_metadata?.name || user.email?.split('@')[0] || 'aí'

  return (
    <div className="min-h-screen flex items-center justify-center p-8 bg-background">
      <div className="w-full max-w-md space-y-8">
        {/* Hero Section */}
        <div className="text-center space-y-4">
          <h1 className="text-4xl font-bold tracking-tight">
            Bem-vindo{displayName !== 'aí' ? `, ${displayName}` : ''}!
          </h1>
          <p className="text-lg text-muted-foreground">
            Vamos configurar seu perfil para começar.
          </p>
        </div>

        {/* Profile Form */}
        <div className="bg-card p-6 rounded-lg border shadow-sm">
          <ProfileForm />
        </div>

        {/* Value Prop */}
        <div className="text-center space-y-2">
          <p className="text-sm text-muted-foreground">
            Com o Obsidian Note Reviewer você pode:
          </p>
          <ul className="text-sm text-muted-foreground space-y-1">
            <li>• Revisar visualmente suas notas markdown</li>
            <li>• Colaborar em tempo real com sua equipe</li>
            <li>• Integrar perfeitamente com o Claude Code</li>
          </ul>
        </div>
      </div>
    </div>
  )
}
```

NOTES:
- Hero section with personalized greeting (per Claude's discretion)
- Checks for existing onboarding to avoid repeated welcome (per locked decision)
- Shows value prop of the tool
- Redirects unauthenticated users to login
  </action>
  <verify>test -f app/welcome/page.tsx && grep -q "ProfileForm" app/welcome/page.tsx && grep -q "Bem-vindo" app/welcome/page.tsx</verify>
  <done>app/welcome/page.tsx renders welcome page with hero section and ProfileForm</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Welcome page with profile completion form and avatar upload</what-built>
  <how-to-verify>
1. Run: npm run dev
2. Create a new test account at http://localhost:3000/auth/signup
3. After signup, verify redirect to /welcome
4. Check personalized greeting appears
5. Test avatar upload:
   - Click "Adicionar foto"
   - Select an image file
   - Verify preview appears
   - Try uploading non-image file (should show error)
   - Try uploading large file (>2MB, should show error)
6. Test display name:
   - Leave empty and try to continue (should show error)
   - Enter name and click "Continuar"
7. Test skip button:
   - Don't fill anything, click "Pular"
   - Verify redirect to /dashboard
8. Test returning user:
   - Logout and login again with same account
   - Verify redirect to /dashboard (NOT /welcome)
9. Verify Supabase Storage has avatar in user-isolated folder
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks and approval:

1. Run: npm run build to verify no TypeScript errors
2. Check welcome page: test -f app/welcome/page.tsx
3. Verify profile form: test -f components/auth/ProfileForm.tsx
4. Check storage utilities: test -f lib/supabase/storage.ts
</verification>

<success_criteria>
- Welcome page appears after signup (not login)
- Personalized greeting with user's name
- Avatar upload works with preview and validation
- Display name is required for submission
- Skip button allows bypassing profile completion
- Returning users skip welcome page (go to dashboard)
- Avatar stored in Supabase Storage with user-isolated folder
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-05-SUMMARY.md` with:
- Onboarding flow implementation
- Avatar upload details
- User data persistence notes
</output>
