---
phase: 01-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/auth/context.tsx
  - lib/auth/hooks.ts
  - app/layout.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "AuthProvider provides auth state (user, session, loading) to entire app"
    - "useAuth hook exposes auth methods (signIn, signUp, signOut, signInWithOAuth)"
    - "Auth context listens to Supabase auth state changes"
    - "AuthProvider wraps the entire application in root layout"
  artifacts:
    - path: "lib/auth/context.tsx"
      provides: "React AuthContext with state and methods"
      exports: ["AuthProvider", "useAuth"]
      contains: "'use client'"
      min_lines: 80
    - path: "lib/auth/hooks.ts"
      provides: "Convenience auth hooks"
      exports: ["useAuth"]
      min_lines: 10
    - path: "app/layout.tsx"
      provides: "Root app layout with AuthProvider"
      contains: "AuthProvider"
      min_lines: 20
  key_links:
    - from: "lib/auth/context.tsx"
      to: "lib/supabase/client.ts"
      via: "import createClient"
      pattern: "from.*supabase/client"
    - from: "app/layout.tsx"
      to: "lib/auth/context.tsx"
      via: "import AuthProvider"
      pattern: "import.*AuthProvider"
---

<objective>
Create React AuthContext for centralized auth state management with custom hooks for accessing auth state and methods.

Purpose: Provides global auth state (user, session, loading) and methods (signIn, signUp, signOut, OAuth) accessible from any component via useAuth hook.

Output: AuthContext provider, useAuth hook, and integration into root layout.
</objective>

<execution_context>
@C:\Users\Alex\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Alex\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/phases/01-authentication/01-RESEARCH.md
@.planning/phases/01-authentication/01-01-PLAN.md

# Research-based patterns (from 01-RESEARCH.md):
- Pattern 2: React Auth Context with proper state management
- Initialize with loading: true to avoid hydration mismatch (Pitfall 3)
- Use 'use client' directive for client-side context
- Listen to auth state changes with onAuthStateChange

# Locked decisions (from Phase Context):
- Google is primary OAuth (first button)
- Email marked "not verified" but functional (no blocking)
</context>

<tasks>

<task type="auto">
  <name>Create AuthContext with state and methods</name>
  <files>lib/auth/context.tsx</files>
  <action>
Create lib/auth/context.tsx:

```typescript
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { User, Session } from '@supabase/supabase-js'
import { createClient } from '@/lib/supabase/client'

type AuthContextType = {
  user: User | null
  session: Session | null
  loading: boolean
  signIn: (email: string, password: string) => Promise<void>
  signUp: (email: string, password: string) => Promise<void>
  signOut: () => Promise<void>
  signInWithOAuth: (provider: 'google' | 'github') => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true) // Start with true to avoid Pitfall 3
  const supabase = createClient()

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    return () => subscription.unsubscribe()
  }, [])

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    if (error) throw error
  }

  const signUp = async (email: string, password: string) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
    })
    if (error) throw error
  }

  const signOut = async () => {
    const { error } = await supabase.auth.signOut()
    if (error) throw error
  }

  const signInWithOAuth = async (provider: 'google' | 'github') => {
    const { error } = await supabase.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo: `${location.origin}/auth/callback`,
      },
    })
    if (error) throw error
  }

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        loading,
        signIn,
        signUp,
        signOut,
        signInWithOAuth,
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

NOTES:
- Uses 'use client' directive (required for context)
- Google is listed before GitHub in provider type hint (primary OAuth per locked decision)
- loading starts as true to prevent Pitfall 3 (hydration mismatch)
- Dynamic origin for OAuth redirect avoids Pitfall 2
- Email verification is NOT enforced (per locked decision - mark but don't block)
  </action>
  <verify>test -f lib/auth/context.tsx && grep -q "'use client'" lib/auth/context.tsx && grep -q "useAuth" lib/auth/context.tsx && grep -q "AuthProvider" lib/auth/context.tsx</verify>
  <done>lib/auth/context.tsx exports AuthProvider component and useAuth hook with full auth state management</done>
</task>

<task type="auto">
  <name>Create convenience auth hooks export</name>
  <files>lib/auth/hooks.ts</files>
  <action>
Create lib/auth/hooks.ts:

```typescript
export { useAuth, AuthProvider } from './context'
```

This provides a clean import path for components: import { useAuth } from '@/lib/auth/hooks'
  </action>
  <verify>test -f lib/auth/hooks.ts && grep -q "useAuth" lib/auth/hooks.ts</verify>
  <done>lib/auth/hooks.ts re-exports useAuth and AuthProvider from context</done>
</task>

<task type="auto">
  <name>Integrate AuthProvider into root layout</name>
  <files>app/layout.tsx</files>
  <action>
Modify app/layout.tsx to wrap children with AuthProvider.

If the file doesn't exist, create it:

```typescript
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { AuthProvider } from '@/lib/auth/context'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Obsidian Note Reviewer',
  description: 'Visual markdown review tool with Claude Code integration',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <AuthProvider>{children}</AuthProvider>
      </body>
    </html>
  )
}
```

If the file exists, add the AuthProvider import and wrap {children} with it.

CRITICAL: AuthProvider must wrap the entire app for auth state to be available everywhere.
  </action>
  <verify>grep -q "AuthProvider" app/layout.tsx && grep -q "from '@/lib/auth/context'" app/layout.tsx</verify>
  <done>app/layout.tsx imports and wraps children with AuthProvider</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Run: npm run build to verify no TypeScript errors
2. Check imports: grep -r "useAuth\|AuthProvider" lib/auth/
3. Verify layout integration: grep -A2 "body" app/layout.tsx | grep -q "AuthProvider"
</verification>

<success_criteria>
- AuthContext provides user, session, loading state
- useAuth hook exposes signIn, signUp, signOut, signInWithOAuth methods
- AuthProvider wraps application in root layout
- No hydration errors (loading: true initialization)
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-02-SUMMARY.md` with:
- Auth context structure
- State management approach
- Integration points
</output>
