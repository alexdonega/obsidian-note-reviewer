---
phase: 01-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/supabase/client.ts
  - lib/supabase/server.ts
  - lib/supabase/middleware.ts
  - middleware.ts
autonomous: true
user_setup:
  - service: supabase
    why: "Authentication backend and storage"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API"
    dashboard_config:
      - task: "Enable Google OAuth provider"
        location: "Supabase Dashboard -> Authentication -> Providers -> Google"
      - task: "Enable GitHub OAuth provider"
        location: "Supabase Dashboard -> Authentication -> Providers -> GitHub"
      - task: "Create avatars storage bucket"
        location: "Supabase Dashboard -> Storage -> New bucket"
      - task: "Configure redirect URLs"
        location: "Supabase Dashboard -> Authentication -> URL Configuration"

must_haves:
  truths:
    - "User can install @supabase/ssr and related packages"
    - "Supabase clients exist for browser, server, and middleware contexts"
    - "Middleware refreshes auth tokens on every request"
    - "Environment variables are configured for Supabase connection"
  artifacts:
    - path: "lib/supabase/client.ts"
      provides: "Browser Supabase client"
      exports: ["createClient"]
      min_lines: 15
    - path: "lib/supabase/server.ts"
      provides: "Server Supabase client with cookie handling"
      exports: ["createClient"]
      min_lines: 30
    - path: "lib/supabase/middleware.ts"
      provides: "Middleware auth state refresh"
      exports: ["updateSession"]
      min_lines: 40
    - path: "middleware.ts"
      provides: "Next.js middleware wrapper"
      contains: "updateSession"
      min_lines: 10
  key_links:
    - from: "middleware.ts"
      to: "lib/supabase/middleware.ts"
      via: "import and call updateSession"
      pattern: "updateSession.*request"
---

<objective>
Install Supabase packages and create client utilities for browser, server, and middleware contexts. This is the foundation for all authentication features.

Purpose: Without proper Supabase client setup, no auth operations can work. The SSR-compatible clients ensure session persistence and token refresh across server and client contexts.

Output: Three client utilities (browser, server, middleware) and Next.js middleware configuration.
</objective>

<execution_context>
@C:\Users\Alex\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Alex\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/phases/01-authentication/01-RESEARCH.md

# Research-based patterns (from 01-RESEARCH.md):
- Use @supabase/ssr (NOT auth-helpers-nextjs - deprecated)
- Pattern 1: Supabase Client Creation with proper cookie configuration
- Avoid implicit OAuth flow (use PKCE)
- Use httpOnly cookies (NOT localStorage)
</context>

<tasks>

<task type="auto">
  <name>Install Supabase packages</name>
  <files>package.json</files>
  <action>
Run: npm install @supabase/supabase-js@^2.39.0 @supabase/ssr@^0.3.0

NOTE: Do NOT install @supabase/auth-helpers-nextjs (deprecated - use @supabase/ssr instead per research).
  </action>
  <verify>grep -E "@supabase/(supabase-js|ssr)" package.json</verify>
  <done>@supabase/supabase-js and @supabase/ssr are in package.json dependencies</done>
</task>

<task type="auto">
  <name>Create browser Supabase client</name>
  <files>lib/supabase/client.ts</files>
  <action>
Create lib/supabase/client.ts:

```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

This follows Pattern 1 from research. Browser client uses createBrowserClient from @supabase/ssr.
  </action>
  <verify>test -f lib/supabase/client.ts && grep -q "createBrowserClient" lib/supabase/client.ts</verify>
  <done>lib/supabase/client.ts exports createClient function using createBrowserClient</done>
</task>

<task type="auto">
  <name>Create server Supabase client with cookie handling</name>
  <files>lib/supabase/server.ts</files>
  <action>
Create lib/supabase/server.ts:

```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

This follows Pattern 1 from research with exact cookie configuration to avoid Pitfall 1 (Missing Cookie Configuration).
  </action>
  <verify>test -f lib/supabase/server.ts && grep -q "createServerClient" lib/supabase/server.ts && grep -q "cookies()" lib/supabase/server.ts</verify>
  <done>lib/supabase/server.ts exports createClient function with proper cookie handling</done>
</task>

<task type="auto">
  <name>Create middleware auth refresh utility</name>
  <files>lib/supabase/middleware.ts</files>
  <action>
Create lib/supabase/middleware.ts:

```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name) {
          return request.cookies.get(name)?.value
        },
        set(name, value, options) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          supabaseResponse = NextResponse.next({
            request,
          })
          supabaseResponse.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name, options) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          supabaseResponse = NextResponse.next({
            request,
          })
          supabaseResponse.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  // IMPORTANT: Avoid writing any logic between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  const {
    data: { user },
  } = await supabase.auth.getUser()

  // Optional: Add redirect protection here
  // if (!user && request.nextUrl.pathname.startsWith('/dashboard')) {
  //   return NextResponse.redirect(new URL('/login', request.url))
  // }

  return supabaseResponse
}
```

This follows Pattern 1 from research. The IMPORTANT comment prevents Pitfall 1 issues.
  </action>
  <verify>test -f lib/supabase/middleware.ts && grep -q "updateSession" lib/supabase/middleware.ts && grep -q "getUser" lib/supabase/middleware.ts</verify>
  <done>lib/supabase/middleware.ts exports updateSession function with cookie refresh logic</done>
</task>

<task type="auto">
  <name>Configure Next.js middleware wrapper</name>
  <files>middleware.ts</files>
  <action>
Create middleware.ts in project root (same level as app/):

```typescript
import { type NextRequest } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

This ensures middleware runs on all routes to refresh tokens (avoiding Pitfall 4: Forgetting Middleware).
  </action>
  <verify>test -f middleware.ts && grep -q "updateSession" middleware.ts && grep -q "matcher" middleware.ts</verify>
  <done>middleware.ts exports middleware function that calls updateSession with proper matcher config</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Run: npm run build (if build script exists) to verify no TypeScript errors
2. Check that all environment variables are referenced: grep -r "NEXT_PUBLIC_SUPABASE" lib/supabase/
3. Verify middleware configuration: grep -A5 "matcher" middleware.ts
</verification>

<success_criteria>
- All three Supabase clients exist and export createClient
- Middleware is configured to run on all relevant routes
- No TypeScript compilation errors
- Pattern follows @supabase/ssr documentation (not deprecated auth-helpers)
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-01-SUMMARY.md` with:
- Tech stack added (supabase-js, ssr)
- Files created
- Any issues encountered
- Environment variables required
</output>
